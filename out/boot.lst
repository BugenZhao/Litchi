     1                                  	org	0x7c00
     2 00000000 E91801                  	jmp 	LABEL_ENTRY			; 保证到这里有 3 个字节
     3                                  
     4                                  %include	"fat12.inc"
     1                              <1> ; Standard FAT12 floppy code
     2 00000003 425A4C4954434849    <1> BS_OEMName		DB 	'BZLITCHI'	; OEM String, 必须 8 个字节
     3 0000000B 0002                <1> BPB_BytsPerSec		DW 	512		; 每扇区字节数
     4 0000000D 01                  <1> BPB_SecPerClus		DB 	1		; 每簇多少扇区
     5 0000000E 0100                <1> BPB_RsvdSecCnt		DW 	1		; Boot 记录占用多少扇区
     6 00000010 02                  <1> BPB_NumFATs		DB 	2		; 共有多少 FAT 表
     7 00000011 E000                <1> BPB_RootEntCnt		DW 	224		; 根目录文件数最大值
     8 00000013 400B                <1> BPB_TotSec16		DW 	2880		; 逻辑扇区总数
     9 00000015 F0                  <1> BPB_Media		DB 	0xF0		; 媒体描述符
    10 00000016 0900                <1> BPB_FATSz16		DW 	9		; 每FAT扇区数
    11 00000018 1200                <1> BPB_SecPerTrk		DW 	18		; 每磁道扇区数
    12 0000001A 0200                <1> BPB_NumHeads		DW 	2		; 磁头数(面数)
    13 0000001C 00000000            <1> BPB_HiddSec		DD 	0		; 隐藏扇区数
    14 00000020 400B0000            <1> BPB_TotSec32		DD 	2880		; 如果 wTotalSectorCount 是 0 由这个值记录扇区数
    15 00000024 00                  <1> BS_DrvNum		DB 	0		; 中断 13 的驱动器号
    16 00000025 00                  <1> BS_Reserved1		DB 	0		; 未使用
    17 00000026 29                  <1> BS_BootSig		DB 	29h		; 扩展引导标记 (29h)
    18 00000027 FFFFFFFF            <1> BS_VolID		DD 	0xffffffff	; 卷序列号
    19 0000002B 425A4C49544348494F- <1> BS_VolLab		DB 	"BZLITCHIOS "	; 卷标, 必须 11 个字节
    19 00000034 5320                <1>
    20 00000036 4641543132202020    <1> BS_FileSysType		DB 	"FAT12   "	; 文件系统类型, 必须 8个字节  
    21                              <1> 
    22                              <1> 
    23                              <1> RootDirSectors		equ	14		; 根据根目录 224 项得到
    24                              <1> SectorNoOfRootDirectory	equ	19		; 根目录开始扇区号，第二个 FAT 表
    25                              <1> SectorNoOfFAT1		equ	1		; FAT1 的第一个扇区号 = BPB_RsvdSecCnt
    26                              <1> DeltaSectorNo		equ	17		; DeltaSectorNo = BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) - 2
    27                              <1> 						; 文件的开始Sector号 = DirEntry中的开始Sector号 + 根目录占用Sector数目 + DeltaSectorNo
    28                              <1> 
    29                              <1> 
    30                              <1> 
    31                              <1> ReadSector:
    32                              <1> 	; start_sector in ax, size in cl, buf in es:bx
    33                              <1> 	; 扇区号 x 除以 18（每个磁道的扇区），商 q，余 r
    34                              <1> 	; 柱面 q >> 1, 磁头 q & 1, 起始扇区 r + 1
    35 0000003E 55                  <1> 	push	bp
    36 0000003F 89E5                <1> 	mov	bp, sp					; 保存栈指针
    37 00000041 6683EC02            <1> 	sub	esp, 2					; 在栈上开辟 2 个字节
    38 00000045 884EFE              <1> 	mov	byte [bp-2], cl
    39 00000048 53                  <1> 	push	bx
    40 00000049 8A1E[1800]          <1> 	mov	bl, [BPB_SecPerTrk]			; 构造除数 18
    41 0000004D F6F3                <1> 	div	bl					; ax/bl (8 bits), q in al, r in ah
    42 0000004F FEC4                <1> 	inc	ah					; r + 1
    43 00000051 88E1                <1> 	mov	cl, ah					; cl -> 起始扇区号
    44 00000053 88C6                <1> 	mov	dh, al					
    45 00000055 80E601              <1> 	and	dh, 1					; dh -> 磁头
    46 00000058 88C5                <1> 	mov	ch, al
    47 0000005A D0ED                <1> 	shr	ch, 1					; ch -> 柱面
    48 0000005C 5B                  <1> 	pop	bx
    49 0000005D 8A16[2400]          <1> 	mov	dl, [BS_DrvNum]				; dl -> 驱动器号
    50                              <1> .DoRead:
    51 00000061 8A46FE              <1> 	mov	al, byte [bp-2]				; al -> 要读扇区数
    52 00000064 B402                <1> 	mov	ah, 2					; 要读了！
    53 00000066 CD13                <1> 	int	13h					; 读！错误时 CF 置 1
    54 00000068 72F7                <1> 	jc	.DoRead					; 错误重试
    55                              <1> 
    56 0000006A 6683C402            <1> 	add	esp, 2
    57 0000006E 5D                  <1> 	pop	bp
    58 0000006F C3                  <1> 	ret
     5                                  
     6                                  BaseOfLoader		equ	0x9000		; Loader 加载基址
     7                                  OffsetOfLoader		equ	0x100		; Loader 加载偏移
     8                                  
     9                                  BaseOfStack		equ	0x7c00		; 栈底，向低地址生长
    10                                  
    11 00000070 0E00                    wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数，
    12                                  						; 在循环中会递减至零.
    13 00000072 0000                    wSectorNo		dw	0		; 要读取的扇区号
    14 00000074 00                      bOdd			db	0		; 奇数还是偶数
    15                                  
    16 00000075 4C4F4144455220204C-     LoaderFileName		db	"LOADER  LIT", 0
    16 0000007E 495400             
    17                                  MessageLength		equ	12
    18                                  MessageTable:
    19 00000081 4E6F206C6F61646572-     NoLoaderMessage		db	"No loader  X"
    19 0000008A 202058             
    20 0000008D 4C6F6164657220666F-     LoaderFoundMessage	db	"Loader found"
    20 00000096 756E64             
    21 00000099 426F6F742072656164-     ReadyMessage		db	"Boot ready !"
    21 000000A2 792021             
    22 000000A5 4C697463686920426F-     HelloMessage		db	"Litchi Boot "
    22 000000AE 6F7420             
    23                                  
    24                                  
    25                                  ;	找到序号为 ax 的 Sector 在 FAT 中的条目, 结果放在 ax 中
    26                                  ;	需要注意的是, 中间需要读 FAT 的扇区到 es:bx 处, 所以函数一开始保存了 es 和 bx
    27                                  GetFATEntry:
    28 000000B1 06                      	push	es
    29 000000B2 53                      	push	bx
    30 000000B3 50                      	push	ax
    31 000000B4 B80090                  	mov	ax, BaseOfLoader; `.
    32 000000B7 2D0001                  	sub	ax, 0100h	;  | 在 BaseOfLoader 后面留出 4K 空间用于存放 FAT
    33 000000BA 8EC0                    	mov	es, ax		; /
    34 000000BC 58                      	pop	ax
    35 000000BD C606[7400]00            	mov	byte [bOdd], 0
    36 000000C2 BB0300                  	mov	bx, 3
    37 000000C5 F7E3                    	mul	bx					; dx:ax = ax * 3
    38 000000C7 BB0200                  	mov	bx, 2
    39 000000CA F7F3                    	div	bx					; dx:ax / 2  ==>  ax <- 商, dx <- 余数
    40 000000CC 83FA00                  	cmp	dx, 0
    41 000000CF 7405                    	jz	LABEL_EVEN
    42 000000D1 C606[7400]01            	mov	byte [bOdd], 1
    43                                  LABEL_EVEN:;偶数
    44                                  	; 现在 ax 中是 FATEntry 在 FAT 中的偏移量,下面来
    45                                  	; 计算 FATEntry 在哪个扇区中(FAT占用不止一个扇区)
    46 000000D6 31D2                    	xor	dx, dx			
    47 000000D8 8B1E[0B00]              	mov	bx, [BPB_BytsPerSec]
    48 000000DC F7F3                    	div	bx ; dx:ax / BPB_BytsPerSec
    49                                  		   ;  ax <- 商 (FATEntry 所在的扇区相对于 FAT 的扇区号)
    50                                  		   ;  dx <- 余数 (FATEntry 在扇区内的偏移)。
    51 000000DE 52                      	push	dx
    52 000000DF BB0000                  	mov	bx, 0 ; bx <- 0 于是, es:bx = (BaseOfLoader - 100):00
    53 000000E2 83C001                  	add	ax, SectorNoOfFAT1 ; 此句之后的 ax 就是 FATEntry 所在的扇区号
    54 000000E5 B102                    	mov	cl, 2
    55 000000E7 E854FF                  	call	ReadSector ; 读取 FATEntry 所在的扇区, 一次读两个, 避免在边界
    56                                  			   ; 发生错误, 因为一个 FATEntry 可能跨越两个扇区
    57 000000EA 5A                      	pop	dx
    58 000000EB 01D3                    	add	bx, dx
    59 000000ED 268B07                  	mov	ax, [es:bx]
    60 000000F0 803E[7400]01            	cmp	byte [bOdd], 1
    61 000000F5 7503                    	jnz	LABEL_EVEN_2
    62 000000F7 C1E804                  	shr	ax, 4
    63                                  LABEL_EVEN_2:
    64 000000FA 25FF0F                  	and	ax, 0FFFh
    65                                  
    66                                  LABEL_GET_FAT_ENRY_OK:
    67                                  
    68 000000FD 5B                      	pop	bx
    69 000000FE 07                      	pop	es
    70 000000FF C3                      	ret
    71                                  
    72                                  
    73                                  
    74                                  EarlyDispStr:
    75                                  	; message_index in di, row:col in dx
    76 00000100 52                      	push	dx					; 坑啊
    77 00000101 8CD8                    	mov	ax, ds
    78 00000103 8EC0                    	mov	es, ax					; es
    79 00000105 B80C00                  	mov	ax, MessageLength
    80 00000108 89C1                    	mov	cx, ax					; calculate string length
    81 0000010A F7E7                    	mul	di					; dx:ax
    82 0000010C 05[8100]                	add	ax, MessageTable
    83 0000010F 89C5                    	mov	bp, ax					; es:bp -> string address
    84 00000111 B80113                  	mov	ax, 0x1301				; ah=0x13 (write string)
    85 00000114 BB0D00                  	mov	bx, 0x000d				; bh=0x00 (page), bl=0x0d (color)
    86 00000117 5A                      	pop	dx
    87 00000118 CD10                    	int	10h
    88 0000011A C3                      	ret
    89                                  
    90                                  ; ReadSector:
    91                                  ; 	; start_sector in ax, size in cl, buf in es:bx
    92                                  ; 	; 扇区号 x 除以 18（每个磁道的扇区），商 q，余 r
    93                                  ; 	; 柱面 q >> 1, 磁头 q & 1, 起始扇区 r + 1
    94                                  ; 	push	bp
    95                                  ; 	mov	bp, sp					; 保存栈指针
    96                                  ; 	sub	esp, 2					; 在栈上开辟 2 个字节
    97                                  ; 	mov	byte [bp-2], cl
    98                                  ; 	push	bx
    99                                  ; 	mov	bl, [BPB_SecPerTrk]			; 构造除数 18
   100                                  ; 	div	bl					; ax/bl (8 bits), q in al, r in ah
   101                                  ; 	inc	ah					; r + 1
   102                                  ; 	mov	cl, ah					; cl -> 起始扇区号
   103                                  ; 	mov	dh, al					
   104                                  ; 	and	dh, 1					; dh -> 磁头
   105                                  ; 	mov	ch, al
   106                                  ; 	shr	ch, 1					; ch -> 柱面
   107                                  ; 	pop	bx
   108                                  ; 	mov	dl, [BS_DrvNum]				; dl -> 驱动器号
   109                                  ; .DoRead:
   110                                  ; 	mov	al, byte [bp-2]				; al -> 要读扇区数
   111                                  ; 	mov	ah, 2					; 要读了！
   112                                  ; 	int	13h					; 读！错误时 CF 置 1
   113                                  ; 	jc	.DoRead					; 错误重试
   114                                  
   115                                  ; 	add	esp, 2
   116                                  ; 	pop	bp
   117                                  ; 	ret
   118                                  
   119                                  ; ;	找到序号为 ax 的 Sector 在 FAT 中的条目, 结果放在 ax 中
   120                                  ; ;	需要注意的是, 中间需要读 FAT 的扇区到 es:bx 处, 所以函数一开始保存了 es 和 bx
   121                                  ; GetFATEntry:
   122                                  ; 	push	es
   123                                  ; 	push	bx
   124                                  ; 	push	ax
   125                                  ; 	mov	ax, BaseOfLoader; `.
   126                                  ; 	sub	ax, 0100h	;  | 在 BaseOfLoader 后面留出 4K 空间用于存放 FAT
   127                                  ; 	mov	es, ax		; /
   128                                  ; 	pop	ax
   129                                  ; 	mov	byte [bOdd], 0
   130                                  ; 	mov	bx, 3
   131                                  ; 	mul	bx					; dx:ax = ax * 3
   132                                  ; 	mov	bx, 2
   133                                  ; 	div	bx					; dx:ax / 2  ==>  ax <- 商, dx <- 余数
   134                                  ; 	cmp	dx, 0
   135                                  ; 	jz	LABEL_EVEN
   136                                  ; 	mov	byte [bOdd], 1
   137                                  ; LABEL_EVEN:;偶数
   138                                  ; 	; 现在 ax 中是 FATEntry 在 FAT 中的偏移量,下面来
   139                                  ; 	; 计算 FATEntry 在哪个扇区中(FAT占用不止一个扇区)
   140                                  ; 	xor	dx, dx			
   141                                  ; 	mov	bx, [BPB_BytsPerSec]
   142                                  ; 	div	bx ; dx:ax / BPB_BytsPerSec
   143                                  ; 		   ;  ax <- 商 (FATEntry 所在的扇区相对于 FAT 的扇区号)
   144                                  ; 		   ;  dx <- 余数 (FATEntry 在扇区内的偏移)。
   145                                  ; 	push	dx
   146                                  ; 	mov	bx, 0 ; bx <- 0 于是, es:bx = (BaseOfLoader - 100):00
   147                                  ; 	add	ax, SectorNoOfFAT1 ; 此句之后的 ax 就是 FATEntry 所在的扇区号
   148                                  ; 	mov	cl, 2
   149                                  ; 	call	ReadSector ; 读取 FATEntry 所在的扇区, 一次读两个, 避免在边界
   150                                  ; 			   ; 发生错误, 因为一个 FATEntry 可能跨越两个扇区
   151                                  ; 	pop	dx
   152                                  ; 	add	bx, dx
   153                                  ; 	mov	ax, [es:bx]
   154                                  ; 	cmp	byte [bOdd], 1
   155                                  ; 	jnz	LABEL_EVEN_2
   156                                  ; 	shr	ax, 4
   157                                  ; LABEL_EVEN_2:
   158                                  ; 	and	ax, 0FFFh
   159                                  
   160                                  ; LABEL_GET_FAT_ENRY_OK:
   161                                  
   162                                  ; 	pop	bx
   163                                  ; 	pop	es
   164                                  ; 	ret
   165                                  
   166                                  
   167                                  LABEL_ENTRY:
   168                                  	; 初始化堆栈
   169 0000011B 8CC8                    	mov	ax, cs
   170 0000011D 8ED8                    	mov	ds, ax
   171 0000011F 8EC0                    	mov	es, ax
   172 00000121 8ED0                    	mov	ss, ax
   173 00000123 BC007C                  	mov	sp, BaseOfStack
   174                                  
   175                                  .ClearScreen:
   176 00000126 B80300                  	mov	ax, 0x0003
   177 00000129 CD10                    	int	10h					; clear screen
   178                                  
   179 0000012B BF0300                  	mov	di, 3					; "Litchi Boot"
   180 0000012E BA0000                  	mov	dx, 0x0000				; row:col
   181 00000131 E8CCFF                  	call	EarlyDispStr
   182                                  
   183                                  .RootSearchStart:
   184 00000134 30E4                    	xor	ah, ah
   185 00000136 30D2                    	xor	dl, dl
   186 00000138 CD13                    	int	13h					; 软驱复位
   187                                  
   188 0000013A C706[7200]1300          	mov	word [wSectorNo], SectorNoOfRootDirectory
   189 00000140 EB48                    	jmp	.RootSearchTest
   190                                  
   191                                  .RootSearchLoop:
   192                                  ; outer loop (sector)
   193                                  	; start_sector in di, size in cl, buf in es:bx
   194 00000142 B80090                  	mov	ax, BaseOfLoader
   195 00000145 8EC0                    	mov	es, ax
   196 00000147 B80001                  	mov	ax, OffsetOfLoader
   197 0000014A 89C3                    	mov	bx, ax					; 临时把根目录文件信息放在这里
   198 0000014C A1[7200]                	mov	ax, [wSectorNo]				; Sector 序号 初始(0)
   199 0000014F B101                    	mov	cl, 1
   200 00000151 E8EAFE                  	call	ReadSector				; 读取根目录的一个 Sector
   201 00000154 BE[7500]                	mov	si, LoaderFileName
   202 00000157 BF0001                  	mov	di, OffsetOfLoader
   203 0000015A FC                      	cld						; clear df flag
   204 0000015B BA1000                  	mov	dx, 10h					; 该扇区条目计数器
   205                                  
   206                                  .SectorSearchStart:
   207                                  ; middle loop (entry)
   208 0000015E 83FA00                  	cmp	dx, 0
   209 00000161 741E                    	je	.NextSector				; 该扇区已经搜索完?
   210 00000163 4A                      	dec	dx
   211 00000164 B90B00                  	mov	cx, 11					; 文件名比较计数器
   212                                  .CompareFileName:
   213                                  ; inner loop (filename)
   214 00000167 83F900                  	cmp	cx, 0
   215 0000016A 7427                    	je	.FileNameFound				; 字符全部匹配?
   216 0000016C 49                      	dec	cx
   217 0000016D AC                      	lodsb						; [ds:si] -> al; 由于 df=0, 递减 si 
   218 0000016E 263A05                  	cmp 	al, byte [es:di]
   219 00000171 7503                    	jne	.FileNameDifferent
   220 00000173 47                      	inc	di
   221 00000174 EBF1                    	jmp	.CompareFileName
   222                                  .FileNameDifferent:
   223 00000176 83E7E0                  	and	di, 0ffe0h				; di 指向条目开头
   224 00000179 83C720                  	add	di, 20h					; 下一个条目
   225 0000017C BE[7500]                	mov	si, LoaderFileName
   226 0000017F EBDD                    	jmp	.SectorSearchStart
   227                                  
   228                                  .RootSearchUpdate:
   229                                  .NextSector:
   230 00000181 8306[7200]01            	add	word [wSectorNo], 1
   231 00000186 FF0E[7000]              	dec	word [wRootDirSizeForLoop]
   232                                  
   233                                  .RootSearchTest:
   234 0000018A 833E[7000]00            	cmp	word [wRootDirSizeForLoop], 0
   235 0000018F 745B                    	je	.NoLoader
   236 00000191 EBAF                    	jmp	.RootSearchLoop
   237                                  
   238                                  
   239                                  .Result:
   240                                  .FileNameFound:
   241 00000193 57                      	push	di
   242 00000194 06                      	push	es
   243 00000195 BF0100                  	mov	di, 1					; "Loader found"
   244 00000198 BA0001                  	mov	dx, 0x0100				; row:col
   245 0000019B E862FF                  	call	EarlyDispStr
   246 0000019E 07                      	pop	es
   247 0000019F 5F                      	pop	di
   248                                  .LoadFile:
   249 000001A0 B80E00                  	mov	ax, RootDirSectors
   250 000001A3 83E7E0                  	and	di, 0FFE0h
   251 000001A6 83C71A                  	add	di, 01Ah				; Loader 的首个 Sector 地址
   252 000001A9 268B0D                  	mov	cx, word [es:di]
   253 000001AC 83F900                  	cmp	cx, 0					; Loader 为空文件
   254 000001AF 743B                    	je	.NoLoader
   255 000001B1 51                      	push	cx					; 保存此 Sector 在 FAT 中的序号
   256 000001B2 01C1                    	add	cx, ax
   257 000001B4 83C111                  	add	cx, DeltaSectorNo			; cl <- LOADER.BIN的起始扇区号(0-based)
   258 000001B7 B80090                  	mov	ax, BaseOfLoader
   259 000001BA 8EC0                    	mov	es, ax					; es <- BaseOfLoader
   260 000001BC BB0001                  	mov	bx, OffsetOfLoader			; bx <- OffsetOfLoader
   261 000001BF 89C8                    	mov	ax, cx					; ax <- Sector 号
   262                                  .LoadLoop:
   263 000001C1 B101                    	mov	cl, 1
   264 000001C3 E878FE                  	call	ReadSector
   265 000001C6 58                      	pop	ax					; 取出此 Sector 在 FAT 中的序号
   266 000001C7 E8E7FE                  	call	GetFATEntry
   267 000001CA 3DFF0F                  	cmp	ax, 0FFFh				; 最后一个簇
   268 000001CD 740F                    	jz	.FileLoaded
   269 000001CF 50                      	push	ax					; 保存 Sector 在 FAT 中的序号
   270 000001D0 BA0E00                  	mov	dx, RootDirSectors
   271 000001D3 01D0                    	add	ax, dx
   272 000001D5 83C011                  	add	ax, DeltaSectorNo
   273 000001D8 031E[0B00]              	add	bx, [BPB_BytsPerSec]
   274 000001DC EBE3                    	jmp	.LoadLoop
   275                                  .FileLoaded:
   276 000001DE BF0200                  	mov	di, 2					; "Ready"
   277 000001E1 BA0002                  	mov	dx, 0x0200				; row:col
   278 000001E4 E819FF                  	call	EarlyDispStr
   279 000001E7 EA00010090              	jmp	BaseOfLoader:OffsetOfLoader		; GO TO LOADER !!!
   280                                  
   281                                  .NoLoader:
   282 000001EC BF0000                  	mov	di, 0					; "No loader"
   283 000001EF BA0C01                  	mov	dx, 0x010C				; row:col
   284 000001F2 E80BFF                  	call	EarlyDispStr
   285                                  Fin:
   286 000001F5 F4                      	hlt
   287 000001F6 EBFD                    	jmp	Fin
