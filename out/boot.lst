     1                                  	org	0x7c00
     2 00000000 E91801                  	jmp 	LABEL_ENTRY			; 保证到这里有 3 个字节
     3                                  
     4                                  ; Standard FAT12 floppy code
     5 00000003 425A4C4954434849        BS_OEMName		DB 	'BZLITCHI'	; OEM String, 必须 8 个字节
     6 0000000B 0002                    BPB_BytsPerSec		DW 	512		; 每扇区字节数
     7 0000000D 01                      BPB_SecPerClus		DB 	1		; 每簇多少扇区
     8 0000000E 0100                    BPB_RsvdSecCnt		DW 	1		; Boot 记录占用多少扇区
     9 00000010 02                      BPB_NumFATs		DB 	2		; 共有多少 FAT 表
    10 00000011 E000                    BPB_RootEntCnt		DW 	224		; 根目录文件数最大值
    11 00000013 400B                    BPB_TotSec16		DW 	2880		; 逻辑扇区总数
    12 00000015 F0                      BPB_Media		DB 	0xF0		; 媒体描述符
    13 00000016 0900                    BPB_FATSz16		DW 	9		; 每FAT扇区数
    14 00000018 1200                    BPB_SecPerTrk		DW 	18		; 每磁道扇区数
    15 0000001A 0200                    BPB_NumHeads		DW 	2		; 磁头数(面数)
    16 0000001C 00000000                BPB_HiddSec		DD 	0		; 隐藏扇区数
    17 00000020 400B0000                BPB_TotSec32		DD 	2880		; 如果 wTotalSectorCount 是 0 由这个值记录扇区数
    18 00000024 00                      BS_DrvNum		DB 	0		; 中断 13 的驱动器号
    19 00000025 00                      BS_Reserved1		DB 	0		; 未使用
    20 00000026 29                      BS_BootSig		DB 	29h		; 扩展引导标记 (29h)
    21 00000027 FFFFFFFF                BS_VolID		DD 	0xffffffff	; 卷序列号
    22 0000002B 425A4C49544348494F-     BS_VolLab		DB 	"BZLITCHIOS "	; 卷标, 必须 11 个字节
    22 00000034 5320               
    23 00000036 4641543132202020        BS_FileSysType		DB 	"FAT12   "	; 文件系统类型, 必须 8个字节  
    24                                  
    25                                  
    26                                  BaseOfStack		equ	0x7c00		; 栈底，向低地址生长
    27                                  BaseOfLoader		equ	0x9000		; Loader 加载基址
    28                                  OffsetOfLoader		equ	0x100		; Loader 加载偏移
    29                                  RootDirSectors		equ	14		; 根据根目录 224 项得到
    30                                  SectorNoOfRootDirectory	equ	19		; 根目录开始扇区号，第二个 FAT 表
    31                                  SectorNoOfFAT1		equ	1		; FAT1 的第一个扇区号 = BPB_RsvdSecCnt
    32                                  DeltaSectorNo		equ	17		; DeltaSectorNo = BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) - 2
    33                                  						; 文件的开始Sector号 = DirEntry中的开始Sector号 + 根目录占用Sector数目 + DeltaSectorNo
    34                                  
    35 0000003E 0E00                    wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数，
    36                                  						; 在循环中会递减至零.
    37 00000040 0000                    wSectorNo		dw	0		; 要读取的扇区号
    38 00000042 00                      bOdd			db	0		; 奇数还是偶数
    39                                  
    40 00000043 4C4F4144455220204C-     LoaderFileName		db	"LOADER  LIT", 0
    40 0000004C 495400             
    41                                  MessageLength		equ	12
    42                                  MessageTable:
    43                                  ; HelloMessage:		db	"Hello, Litchi!", 0x0d, 0x0a, "BugenZhao 2020", 0x0d, 0x0a
    44                                  ; HelloMessageEnd:
    45 0000004F 4E6F206C6F61646572-     NoLoaderMessage		db	"No loader  X"
    45 00000058 202058             
    46 0000005B 4C6F6164657220666F-     LoaderFoundMessage	db	"Loader found"
    46 00000064 756E64             
    47 00000067 426F6F742052656164-     ReadyMessage		db	"Boot Ready! "
    47 00000070 792120             
    48 00000073 4C697463686920426F-     HelloMessage		db	"Litchi Boot "
    48 0000007C 6F7420             
    49                                  
    50                                  
    51                                  
    52                                  BootDispStr:
    53                                  	; message_index in di, row:col in dx
    54 0000007F 52                      	push	dx					; 坑啊
    55 00000080 8CD8                    	mov	ax, ds
    56 00000082 8EC0                    	mov	es, ax					; es
    57 00000084 B80C00                  	mov	ax, MessageLength
    58 00000087 89C1                    	mov	cx, ax					; calculate string length
    59 00000089 F7E7                    	mul	di					; dx:ax
    60 0000008B 05[4F00]                	add	ax, MessageTable
    61 0000008E 89C5                    	mov	bp, ax					; es:bp -> string address
    62 00000090 B80113                  	mov	ax, 0x1301				; ah=0x13 (write string)
    63 00000093 BB0D00                  	mov	bx, 0x000d				; bh=0x00 (page), bl=0x0d (color)
    64 00000096 5A                      	pop	dx
    65 00000097 CD10                    	int	10h
    66 00000099 C3                      	ret
    67                                  
    68                                  ReadSector:
    69                                  	; start_sector in ax, size in cl, buf in es:bx
    70                                  	; 扇区号 x 除以 18（每个磁道的扇区），商 q，余 r
    71                                  	; 柱面 q >> 1, 磁头 q & 1, 起始扇区 r + 1
    72 0000009A 55                      	push	bp
    73 0000009B 89E5                    	mov	bp, sp					; 保存栈指针
    74 0000009D 6683EC02                	sub	esp, 2					; 在栈上开辟 2 个字节
    75 000000A1 884EFE                  	mov	byte [bp-2], cl
    76 000000A4 53                      	push	bx
    77 000000A5 8A1E[1800]              	mov	bl, [BPB_SecPerTrk]			; 构造除数 18
    78 000000A9 F6F3                    	div	bl					; ax/bl (8 bits), q in al, r in ah
    79 000000AB FEC4                    	inc	ah					; r + 1
    80 000000AD 88E1                    	mov	cl, ah					; cl -> 起始扇区号
    81 000000AF 88C6                    	mov	dh, al					
    82 000000B1 80E601                  	and	dh, 1					; dh -> 磁头
    83 000000B4 88C5                    	mov	ch, al
    84 000000B6 D0ED                    	shr	ch, 1					; ch -> 柱面
    85 000000B8 5B                      	pop	bx
    86 000000B9 8A16[2400]              	mov	dl, [BS_DrvNum]				; dl -> 驱动器号
    87                                  .DoRead:
    88 000000BD 8A46FE                  	mov	al, byte [bp-2]				; al -> 要读扇区数
    89 000000C0 B402                    	mov	ah, 2					; 要读了！
    90 000000C2 CD13                    	int	13h					; 读！错误时 CF 置 1
    91 000000C4 72F7                    	jc	.DoRead					; 错误重试
    92                                  
    93 000000C6 6683C402                	add	esp, 2
    94 000000CA 5D                      	pop	bp
    95 000000CB C3                      	ret
    96                                  
    97                                  ;	找到序号为 ax 的 Sector 在 FAT 中的条目, 结果放在 ax 中
    98                                  ;	需要注意的是, 中间需要读 FAT 的扇区到 es:bx 处, 所以函数一开始保存了 es 和 bx
    99                                  GetFATEntry:
   100 000000CC 06                      	push	es
   101 000000CD 53                      	push	bx
   102 000000CE 50                      	push	ax
   103 000000CF B80090                  	mov	ax, BaseOfLoader; `.
   104 000000D2 2D0001                  	sub	ax, 0100h	;  | 在 BaseOfLoader 后面留出 4K 空间用于存放 FAT
   105 000000D5 8EC0                    	mov	es, ax		; /
   106 000000D7 58                      	pop	ax
   107 000000D8 C606[4200]00            	mov	byte [bOdd], 0
   108 000000DD BB0300                  	mov	bx, 3
   109 000000E0 F7E3                    	mul	bx					; dx:ax = ax * 3
   110 000000E2 BB0200                  	mov	bx, 2
   111 000000E5 F7F3                    	div	bx					; dx:ax / 2  ==>  ax <- 商, dx <- 余数
   112 000000E7 83FA00                  	cmp	dx, 0
   113 000000EA 7405                    	jz	LABEL_EVEN
   114 000000EC C606[4200]01            	mov	byte [bOdd], 1
   115                                  LABEL_EVEN:;偶数
   116                                  	; 现在 ax 中是 FATEntry 在 FAT 中的偏移量,下面来
   117                                  	; 计算 FATEntry 在哪个扇区中(FAT占用不止一个扇区)
   118 000000F1 31D2                    	xor	dx, dx			
   119 000000F3 8B1E[0B00]              	mov	bx, [BPB_BytsPerSec]
   120 000000F7 F7F3                    	div	bx ; dx:ax / BPB_BytsPerSec
   121                                  		   ;  ax <- 商 (FATEntry 所在的扇区相对于 FAT 的扇区号)
   122                                  		   ;  dx <- 余数 (FATEntry 在扇区内的偏移)。
   123 000000F9 52                      	push	dx
   124 000000FA BB0000                  	mov	bx, 0 ; bx <- 0 于是, es:bx = (BaseOfLoader - 100):00
   125 000000FD 83C001                  	add	ax, SectorNoOfFAT1 ; 此句之后的 ax 就是 FATEntry 所在的扇区号
   126 00000100 B102                    	mov	cl, 2
   127 00000102 E895FF                  	call	ReadSector ; 读取 FATEntry 所在的扇区, 一次读两个, 避免在边界
   128                                  			   ; 发生错误, 因为一个 FATEntry 可能跨越两个扇区
   129 00000105 5A                      	pop	dx
   130 00000106 01D3                    	add	bx, dx
   131 00000108 268B07                  	mov	ax, [es:bx]
   132 0000010B 803E[4200]01            	cmp	byte [bOdd], 1
   133 00000110 7503                    	jnz	LABEL_EVEN_2
   134 00000112 C1E804                  	shr	ax, 4
   135                                  LABEL_EVEN_2:
   136 00000115 25FF0F                  	and	ax, 0FFFh
   137                                  
   138                                  LABEL_GET_FAT_ENRY_OK:
   139                                  
   140 00000118 5B                      	pop	bx
   141 00000119 07                      	pop	es
   142 0000011A C3                      	ret
   143                                  
   144                                  
   145                                  LABEL_ENTRY:
   146                                  	; 初始化堆栈
   147 0000011B 8CC8                    	mov	ax, cs
   148 0000011D 8ED8                    	mov	ds, ax
   149 0000011F 8EC0                    	mov	es, ax
   150 00000121 8ED0                    	mov	ss, ax
   151 00000123 BC007C                  	mov	sp, BaseOfStack
   152                                  
   153                                  ClearScreen:
   154 00000126 B80300                  	mov	ax, 0x0003
   155 00000129 CD10                    	int	10h					; clear screen
   156                                  
   157 0000012B BF0300                  	mov	di, 3					; "Litchi Boot"
   158 0000012E BA0000                  	mov	dx, 0x0000				; row:col
   159 00000131 E84BFF                  	call	BootDispStr
   160                                  
   161 00000134 30E4                    	xor	ah, ah
   162 00000136 30D2                    	xor	dl, dl
   163 00000138 CD13                    	int	13h					; 软驱复位
   164                                  
   165 0000013A C706[4000]1300          	mov	word [wSectorNo], SectorNoOfRootDirectory
   166 00000140 EB48                    	jmp	.RootSearchTest
   167                                  
   168                                  .RootSearchLoop:
   169                                  ; outer loop (sector)
   170                                  	; start_sector in di, size in cl, buf in es:bx
   171 00000142 B80090                  	mov	ax, BaseOfLoader
   172 00000145 8EC0                    	mov	es, ax
   173 00000147 B80001                  	mov	ax, OffsetOfLoader
   174 0000014A 89C3                    	mov	bx, ax					; 临时把根目录文件信息放在这里
   175 0000014C A1[4000]                	mov	ax, [wSectorNo]				; Sector 序号 初始(0)
   176 0000014F B101                    	mov	cl, 1
   177 00000151 E846FF                  	call	ReadSector				; 读取根目录的一个 Sector
   178 00000154 BE[4300]                	mov	si, LoaderFileName
   179 00000157 BF0001                  	mov	di, OffsetOfLoader
   180 0000015A FC                      	cld						; clear df flag
   181 0000015B BA1000                  	mov	dx, 10h					; 该扇区条目计数器
   182                                  
   183                                  .SectorSearchStart:
   184                                  ; middle loop (entry)
   185 0000015E 83FA00                  	cmp	dx, 0
   186 00000161 741E                    	je	.NextSector				; 该扇区已经搜索完?
   187 00000163 4A                      	dec	dx
   188 00000164 B90B00                  	mov	cx, 11					; 文件名比较计数器
   189                                  .CompareFileName:
   190                                  ; inner loop (filename)
   191 00000167 83F900                  	cmp	cx, 0
   192 0000016A 7432                    	je	.FileNameFound				; 字符全部匹配?
   193 0000016C 49                      	dec	cx
   194 0000016D AC                      	lodsb						; [ds:si] -> al; 由于 df=0, 递减 si 
   195 0000016E 263A05                  	cmp 	al, byte [es:di]
   196 00000171 7503                    	jne	.FileNameDifferent
   197 00000173 47                      	inc	di
   198 00000174 EBF1                    	jmp	.CompareFileName
   199                                  .FileNameDifferent:
   200 00000176 83E7E0                  	and	di, 0ffe0h				; di 指向条目开头
   201 00000179 83C720                  	add	di, 20h					; 下一个条目
   202 0000017C BE[4300]                	mov	si, LoaderFileName
   203 0000017F EBDD                    	jmp	.SectorSearchStart
   204                                  
   205                                  .RootSearchUpdate:
   206                                  .NextSector:
   207 00000181 8306[4000]01            	add	word [wSectorNo], 1
   208 00000186 FF0E[3E00]              	dec	word [wRootDirSizeForLoop]
   209                                  
   210                                  .RootSearchTest:
   211 0000018A 833E[3E00]00            	cmp	word [wRootDirSizeForLoop], 0
   212 0000018F 7402                    	je	.NoLoader
   213 00000191 EBAF                    	jmp	.RootSearchLoop
   214                                  
   215                                  
   216                                  .Result:
   217                                  .NoLoader:
   218 00000193 BF0000                  	mov	di, 0					; "No loader"
   219 00000196 BA0C01                  	mov	dx, 0x010C				; row:col
   220 00000199 E8E3FE                  	call	BootDispStr
   221 0000019C EB59                    	jmp	Fin
   222                                  
   223                                  .FileNameFound:
   224 0000019E 57                      	push	di
   225 0000019F 06                      	push	es
   226 000001A0 BF0100                  	mov	di, 1					; "Loader found"
   227 000001A3 BA0001                  	mov	dx, 0x0100				; row:col
   228 000001A6 E8D6FE                  	call	BootDispStr
   229 000001A9 07                      	pop	es
   230 000001AA 5F                      	pop	di
   231                                  .LoadFile:
   232 000001AB B80E00                  	mov	ax, RootDirSectors
   233 000001AE 83E7E0                  	and	di, 0FFE0h
   234 000001B1 83C71A                  	add	di, 01Ah				; Loader 的首个 Sector 地址
   235 000001B4 268B0D                  	mov	cx, word [es:di]
   236 000001B7 83F900                  	cmp	cx, 0					; Loader 为空
   237 000001BA 74D7                    	je	.NoLoader
   238 000001BC 51                      	push	cx					; 保存此 Sector 在 FAT 中的序号
   239 000001BD 01C1                    	add	cx, ax
   240 000001BF 83C111                  	add	cx, DeltaSectorNo			; cl <- LOADER.BIN的起始扇区号(0-based)
   241 000001C2 B80090                  	mov	ax, BaseOfLoader
   242 000001C5 8EC0                    	mov	es, ax					; es <- BaseOfLoader
   243 000001C7 BB0001                  	mov	bx, OffsetOfLoader			; bx <- OffsetOfLoader
   244 000001CA 89C8                    	mov	ax, cx					; ax <- Sector 号
   245                                  .LoadLoop:
   246                                  
   247 000001CC B101                    	mov	cl, 1
   248 000001CE E8C9FE                  	call	ReadSector
   249 000001D1 58                      	pop	ax					; 取出此 Sector 在 FAT 中的序号
   250 000001D2 E8F7FE                  	call	GetFATEntry
   251 000001D5 3DFF0F                  	cmp	ax, 0FFFh
   252 000001D8 740F                    	jz	.FileLoaded
   253 000001DA 50                      	push	ax					; 保存 Sector 在 FAT 中的序号
   254 000001DB BA0E00                  	mov	dx, RootDirSectors
   255 000001DE 01D0                    	add	ax, dx
   256 000001E0 83C011                  	add	ax, DeltaSectorNo
   257 000001E3 031E[0B00]              	add	bx, [BPB_BytsPerSec]
   258 000001E7 EBE3                    	jmp	.LoadLoop
   259                                  
   260                                  .FileLoaded:
   261 000001E9 BF0200                  	mov	di, 2					; "Ready"
   262 000001EC BA0002                  	mov	dx, 0x0200				; row:col
   263 000001EF E88DFE                  	call	BootDispStr
   264                                  
   265 000001F2 EA00010090              	jmp	BaseOfLoader:OffsetOfLoader		; GO TO LOADER !!!
   266                                  Fin:
   267 000001F7 F4                      	hlt
   268 000001F8 EBFD                    	jmp	Fin
